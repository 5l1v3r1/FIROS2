# Helloworld Orion example

For this example we are going to setup a FIROS2 Bridge to be used to communicate ROS2 Talker example with FIWARE Orion contextBroker (NGSIv2 protocol).

### Prerequisites:

- Installed and working ROS2 with Fast-RTPS and FIROS2.
- *ROS2* [Talker/Listener example](https://github.com/ros2/ros2/wiki/Linux-Development-Setup#try-some-examples>).
- FIWARE Orion contextBroker available for testing.

### Bridge library:

In this example, we will use the builtin library *isbridgengsiv2lib*, included with the installation of FIROS2.

### IDL files:

FIROS2 includes a JsonNGSIv2.idl, which will be used by the builtin NGSIv2 libraries. This IDL file is very simple, and contains two strings, *entityId* and *data*.

- *entityId* is intended to be filled with the entityId that will use contextBroker to identify the entity "Helloworld", by the **transformation library** (explained later) which will convert ros2 data to ngsiv2 protocol.

- *data* will contain the attributes to be update to contextBroker.

To sending data to ROS2 we will use the String_.idl that encapsulates a string complatible with the used by the *talker/listener* demo in ROS2.

All this IDL files are already generated by *fastrtpsgen*, but maybe they need to be regenerated if *fastrtpsgen* changes in the future.

### Transformation library:

Following the example in templatelib.cpp, we have already created a library to transform from ROS2 to NGSIv2 (only transformation function is shown in order to clarity).

	extern "C" void USER_LIB_EXPORT transform(
			SerializedPayload_t *serialized_input,
			SerializedPayload_t *serialized_output)
	{
	    // User types
	    std_msgs::msg::dds_::String_ data;
	    std_msgs::msg::dds_::String_PubSubType data_pst;

	    JsonNGSIv2PubSubType string_pst;
	    JsonNGSIv2 string_data;

	    // Deserialization
	    data_pst.deserialize(serialized_input, &data);

	    std::string msg = data.data_();
	    msg = msg.substr(msg.find(":") + 2); // ": "

	    // Custom transformation
	    std:: string json = "{\"count\": { \"value\": " + msg + "} }";
	    string_data.entityId("Helloworld"); // Fixed for the example
	    string_data.data(json);
	    std::cout << string_data.data() << std::endl;

	    // Serialization
	    serialized_output->reserve(string_pst.m_typeSize);
	    string_pst.serialize(&string_data, serialized_output);
	}


The logic is very simple. The function **transform** receives the data as a String_ structure and creates a JSON with the data as expected by the contextBroker.

In both cases, serialization and deserialization are applied as needed by SerializedPayload_t.

### Config.xml

The *config.cml* file used in this example is the following:

    <is>
        <bridge>
            <bridge_type>unidirectional</bridge_type>
            <subscriber>
                <participant>ros2_subscriber</participant>
                <domain>0</domain>
                <topic>chatter</topic>
                <type>std_msgs::msg::dds_::String_</type>
                <partition>rt</partition>
            </subscriber>
            <bridge_configuration>
                <ngsiv2>
                    <participant>ngsiv2_publisher</participant>
                    <id>Helloworld</id>
                    <host>contextBroker_host</host>
                    <port>contextBroker_port</port>
                </ngsiv2>
            </bridge_configuration>
            <transformation>/path/to/compiled/library/libuserlib.so</transformation>
            <bridge_library>libisbridgengsiv2lib.so</bridge_library>
        </bridge>
    </is>

Our ROS2 Topic is chatter in the partition "rt" and with domain 0. Exactly the same configuration that talker/listener ROS2 example uses.
NGSIv2 will be configured to connect with a contextBroker server at localhost in port 1026.

### Run the example

FIrst, we need to compile the example transformation library (remember to have already installed and working ROS2, with Fast-RTPS and FIROS2).
Let's suppose our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_orion
	$ mkdir build && cd build
	$ cmake ..
	$ make

Two auxiliary utilities are compiled:

**cb_create_helloworld**: Allows you to create a "Helloworld" entity with the expected structure in the Orion contextBroker.

	./cb_create_helloworld localhost:1026

This entity must exists in the contextBroker. If no url is specified, the "localhost:1026" will be used.

**cb_get_helloworld**: Allows you to check the count attribute value of the "Helloworld" entity.

	./cb_get_helloworld localhost:1026

Again, if no url is given, "localhost:1026" will be used.

Finally, we are in condition to launch the test.
Let's suppose again that our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_orion
	$ firos2 config.xml

In other terminal, launch ROS2 talker example:

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ ros2 run demo_nodes_cpp talker

Now, you can check how firos2 is updating contextBroker's "Helloworld" entity with the count received from ROS2's talker using *cb_get_helloworld*.
