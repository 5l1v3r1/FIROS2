# Helloworld ROS2 example

For this example we are going to setup a FIROS2 Bridge to be used to communicate FIWARE Orion contextBroker (NGSIv2 protocol) with ROS2 Listener example.

### Prerequisites:

- Installed and working ROS2 with Fast-RTPS and FIROS2.
- *ROS2* [Talker/Listener example](https://github.com/ros2/ros2/wiki/Linux-Development-Setup#try-some-examples>).

### Bridge library:

In this example, we will use the builtin library *rsngsirtpsv2lib*, included with the installation of FIROS2.

### IDL files:

FIROS2 includes a JsonNGSIv2.idl, which will be used by the builtin NGSIv2 libraries. This IDL file is very simple, and contains two strings, *entityId* and *data*.

- *entityId* is intended to be filled with the entityId that will use contextBroker to identify the entity "Helloworld", by the **transformation library** (explained later) which will convert ngsiv2 data to ros2 protocol.

- *data* will contain raw JSON received from contextBroker.

To sending data to ROS2 we will use the String_.idl that encapsulates a string complatible with the used by the *talker/listener* demo in ROS2.

All this IDL files are already generated by *fastrtpsgen*, but maybe they need to be regenerated if *fastrtpsgen* changes in the future.

### Transformation library:

Following the example in templatelib.cpp, we have already created a library to transform from NGSIv2 to ROS2 (only transformation function is shown in order to clarity).

	extern "C" void USER_LIB_EXPORT transform(
			SerializedPayload_t *serialized_input,
			SerializedPayload_t *serialized_output)
	{
	    // User types
	    std_msgs::msg::dds_::String_ data;
	    std_msgs::msg::dds_::String_PubSubType data_pst;

	    JsonNGSIv2PubSubType string_pst;
	    JsonNGSIv2 string_data;

	    // Deserialization
	    string_pst.deserialize(serialized_input, &string_data);

	    // Custom transformation
	    std::stringstream ss(string_data.data());
	    Json::Value root;
	    Json::CharReaderBuilder jsonReader;
	    std::string errs;
	    if (Json::parseFromStream(jsonReader, ss, &root, &errs))
	    {
		Json::Value data_node = root["data"];
		Json::Value helloworld = data_node[0];
		data.data_("Helloworld: " + helloworld["count"]["value"].asString());
		// Serialization
		serialized_output->reserve(data_pst.m_typeSize);
		data_pst.serialize(&data, serialized_output);
	    }
	    else
	    {
		std::cout  << "Failed to parse" << errs;
	    }	
	}


The logic is very simple. The function **transform** receives the data as a JsonNGSIv2 structure and creates a String with the data as expected by ROS2.

In both cases, serialization and deserialization are applied as needed by SerializedPayload_t.

### Config.xml

The *config.cml* file used in this example is the following:

	<is>
		<bridge>
			<bridge_type>unidirectional</bridge_type>
			<subscriber>
				<participant>ngsiv2_subscriber</participant>
				<id>Helloworld</id>
				<host>localhost</host>
				<port>1026</port>
				<subscription>
					<type>Helloworld</type> <!-- optional -->
					<notifs>count</notifs> <!-- comma separated -->
					<listener_host>localhost</listener_host>
					<listener_port>12345</listener_port>
				</subscription>
			</subscriber>
			<publisher>
				<participant>ros2_publisher</participant>
				<domain>0</domain>
				<topic>chatter</topic>
				<type>std_msgs::msg::dds_::String_</type>
				<partition>rt</partition>
			</publisher>
			<transformFromNGSIv2>/home/luisgp/ros2_ws/src/ros2/firos2/examples/helloworld_ros2/build/libuserlib.so</transformFromNGSIv2>
			<bridge_library>librsngsiv2rtpsbridgelib.so</bridge_library>
		</bridge>
	</is>

Our ROS2 Topic is chatter in the partition "rt" and with domain 0. Exactly the same configuration that talker/listener ROS2 example uses.
NGSIv2 will be configured to connect with a contextBroker server at localhost in port 1026, and will configure a subscription to any change in any entity of type "Helloworld", and asks to be notified only *count* attribute. 

Finally we will listen to these changes at localhost in port 12345 (internally *librsngsiv2rtpsbridgelib* library launches the server to listen at the address specified in the subscription field).

### Run the example

FIrst, we need to compile the example transformation library (remember to have already installed and working ROS2, with Fast-RTPS and FIROS2).
Let's suppose our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_ros2
	$ mkdir build && cd build
	$ cmake ..
	$ make

Two auxiliary utilities are compiled:

**cb_create_helloworld**: Allows you to create a "Helloworld" entity with the expected structure in the Orion contextBroker.

	./cb_create_helloworld localhost:1026

This entity must exists in the contextBroker. If no url is specified, the "localhost:1026" will be used.

**cb_update_attr**: Allows you to modify an attribute value of a entity in the contextBroker.
The following example will modify *count* attribute of *Helloworld* entity setting its value to 5.

	./cb_update_attr localhost:1026 Helloworld count n 5

Finally, we are in condition to launch the test.
Let's suppose again that our ROS2 path is **~/ros2**

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ cd src/ros2/firos2/examples/helloworld_ros2
	$ firos2 config.xml

In other terminal, launch ROS2 listener example:

	$ cd ~/ros2
	$ . ./install/local_setup.bash
	$ ros2 run demo_nodes_cpp listener

Now, you can check how ROS2's listener receives any change made in the *count* of "Helloworld" using *cb_update_attr*.
